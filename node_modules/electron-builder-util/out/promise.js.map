{
  "version": 3,
  "file": "promise.js",
  "sourceRoot": "",
  "sources": [
    "../src/promise.ts"
  ],
  "names": [],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAQA,AAA6F,AAC7F,AAAM;;oEAAC,AAAK,WAA4B,AAAmB,SAAE,AAA8C;AACzG,YAAI,AAAM,SAAa,AAAI;AAC3B,YAAI,AAAC;AACH,AAAM,qBAAG,MAAM,AAAO,AACxB;AAAC,UACD,AAAK,AAAC,OAAC,AAAa,AAAC,eAAC,AAAC;AACrB,gBAAI,AAAC;AACH,sBAAM,AAAI,KAAC,AAAI,AAAC,AAClB;AAAC,cACD,AAAK,AAAC,OAAC,AAAS,AAAC,WAAC,AAAC;AACjB,sBAAM,IAAI,AAAW,YAAC,CAAC,AAAa,eAAE,AAAS,AAAC,AAAC,AACnD;AAAC;AAED,kBAAM,AAAa,AACrB;AAAC;AAED,YAAI,AAAC;AACH,kBAAM,AAAI,KAAC,AAAK,AAAC,AACnB;AAAC,UACD,AAAK,AAAC,OAAC,AAAS,AAAC,WAAC,AAAC;AACjB,kBAAM,AAAS,AACjB;AAAC;AACD,AAAM,eAAC,AAAM,AACf;AAAC,AAED,AAAM;;;;;;;;;;;;;AAjCN,AAAO,AAAE,AAAG,AAAE,AAAM,AAAO,AAE3B,AAAM;;;;;;2BAA4B,AAAY;AAC5C,AAAO,YAAC,AAAK,MAAC,AAAG,mCAAC,CAAC,AAAK,MAAC,AAAK,SAAI,AAAK,AAAC,OAAC,AAAQ,AAAE,AAAC,AAAC;AACrD,AAAO,YAAC,AAAI,KAAC,CAAC,AAAC,AAAC,AAClB;AAAC,OA4BwB,oBAAQ,AAAK;AACpC,gBAAY,AAAoB;YAAE,8EAAkB,AAAkB;;AACpE,YAAI,AAAC,IAAG,AAAO;AACf,YAAI,AAAC,IAAG,AAAC;AACT,AAAG,AAAC,aAAC,MAAM,AAAK,SAAI,AAAM,AAAC,QAAC,AAAC;AAC3B,kBAAM,AAAM,SAAG,AAAS,YAAG,AAAC,AAAE,MAAG,AAAG;AACpC,AAAC,iBAAI,AAAM,SAAG,AAAM,SAAG,AAAG,IAAC,AAAM,OAAC,AAAE,AAAC,MAAG,AAAI,OAAG,AAAM,MAAC,AAAK,AAC7D;AAAC;AACD,AAAK,cAAC,AAAC,AAAC,AACV;AAAC,AACF,AAED,AAAM;;;aAAc,AAA6B;AAC/C,UAAM,AAAM,SAAiB,AAAE;AAC/B,AAAM,WAAC,AAAe,gDAAC,AAAG,IAAC,AAAQ,SAAC,AAAG,IAAC,AAAE,MAAI,AAAE,GAAC,AAAK,MAAC,AAAE,MAAI,AAAM,OAAC,AAAI,KAAC,AAAE,AAAC,AAAC,AAAC,AAAC,OAC5E,AAAI,KAAC,MAAM,AAAU,WAAC,AAAM,AAAC,AAAC,AACnC;AAAC,AAED,AAAM;oBAAqB,AAAoB;AAC7C,AAAE,AAAC,QAAC,AAAM,OAAC,AAAM,WAAK,AAAC,AAAC,GAAC,AAAC;AACxB,cAAM,AAAM,OAAC,AAAC,AAAC,AACjB;AAAC,AACD,AAAI,WAAC,AAAE,AAAC,IAAC,AAAM,OAAC,AAAM,SAAG,AAAC,AAAC,GAAC,AAAC;AAC3B,cAAM,IAAI,AAAW,YAAC,AAAM,QAAE,AAAkB,AAAC,AACnD;AAAC,AACH;AAAC",
  "sourcesContent": [
    "import BluebirdPromise from \"bluebird-lst\"\nimport { red } from \"chalk\"\n\nexport function printErrorAndExit(error: Error) {\n  console.error(red((error.stack || error).toString()))\n  process.exit(-1)\n}\n\n// you don't need to handle error in your task - it is passed only indicate status of promise\nexport async function executeFinally<T>(promise: Promise<T>, task: (errorOccurred: boolean) => Promise<any>): Promise<T> {\n  let result: T | null = null\n  try {\n    result = await promise\n  }\n  catch (originalError) {\n    try {\n      await task(true)\n    }\n    catch (taskError) {\n      throw new NestedError([originalError, taskError])\n    }\n\n    throw originalError\n  }\n\n  try {\n    await task(false)\n  }\n  catch (taskError) {\n    throw taskError\n  }\n  return result\n}\n\nexport class NestedError extends Error {\n  constructor(errors: Array<Error>, message: string = \"Compound error: \") {\n    let m = message\n    let i = 1\n    for (const error of errors) {\n      const prefix = \"Error #\" + i++ + \" \"\n      m += \"\\n\\n\" + prefix + \"-\".repeat(80) + \"\\n\" + error!.stack\n    }\n    super(m)\n  }\n}\n\nexport function all(promises: Array<Promise<any>>): BluebirdPromise<any> {\n  const errors: Array<Error> = []\n  return BluebirdPromise.all(promises.map(it => it.catch(it => errors.push(it))))\n    .then(() => throwError(errors))\n}\n\nexport function throwError(errors: Array<Error>) {\n  if (errors.length === 1) {\n    throw errors[0]\n  }\n  else if (errors.length > 1) {\n    throw new NestedError(errors, \"Cannot cleanup: \")\n  }\n}"
  ]
}
